# üî¥ ISSUE ANALYSIS: PII Redaction & Risk Scoring Problems

## Summary of Issues Found

You're experiencing **4 critical issues** in the API response. This document identifies the root causes and required fixes.

---

## üîç ISSUE #1: Redacted Input Shows Generic `[PII Redacted]` Instead of Entity-Specific Token

### Problem
**Expected:** `"What is my credit card number [CREDIT_CARD_REDACTED]?"`  
**Actual:** `"[PII Redacted]"`

### Root Cause
**File:** `sentinel/api/server.py`  
**Line:** 490

```python
# WRONG:
redacted_input = req.user_input if not pii_detected else "[PII Redacted]"
```

The code is using a **hardcoded generic string** `[PII Redacted]` instead of the properly redacted input that was generated by the PII detector.

### Solution
The properly redacted input is already in `result_state["redacted_input"]`. Use that instead:

```python
# CORRECT:
redacted_input = result_state.get("redacted_input", req.user_input)
```

---

## üî¥ ISSUE #2: Risk Score is 0 Even Though PII Was Detected

### Problem
**Expected:** `risk_score` should be HIGH (e.g., 0.9+) when PII is detected  
**Actual:** `risk_score: 0`

### Root Cause
The risk score extraction is looking at the wrong location or the `threats` list is empty:

**File:** `sentinel/api/server.py`  
**Lines:** 474-479

```python
max_risk_score = 0.0
if threats:
    if isinstance(threats[0], dict):
        max_risk_score = max([t.get("risk_score", 0.0) for t in threats], default=0.0)
    else:
        max_risk_score = max([t.risk_score for t in threats], default=0.0)
```

**Issue:** The `threats` list might be empty even though PII was detected. The risk scoring should also check `risk_scores` from the input guard layer.

### Solution
Use the aggregated risk score from the input guard layer:

```python
# BETTER:
aggregated_risk = result_state.get("aggregated_risk", {})
max_risk_score = aggregated_risk.get("overall_risk_score", 0.0)

# If no aggregated risk, fallback to threats
if max_risk_score == 0.0 and threats:
    if isinstance(threats[0], dict):
        max_risk_score = max([t.get("risk_score", 0.0) for t in threats], default=0.0)
    else:
        max_risk_score = max([t.risk_score for t in threats], default=0.0)
```

---

## üî¥ ISSUE #3: PII Count Shows 3 Instead of 1 (Duplicate Detection)

### Problem
**Expected:** `pii_count: 1` (one credit card number)  
**Actual:** `pii_count: 3`

### Root Cause
The PII detector is detecting the same credit card number **multiple times** - likely:
1. Once via regex pattern (exact match)
2. Again via spaCy NER model
3. Possibly a third time from another pattern overlap

**File:** `sentinel/input_guard.py`  
**Lines:** 212-230 (detect_pii method)

```python
def detect_pii(self, text: str) -> List[RedactedEntity]:
    """Detect all PII/PCI/PHI entities in text"""
    entities = []

    if not self.config.enabled:
        return entities

    # Regex-based detection
    if self.config.use_regex:
        entities.extend(self._detect_with_regex(text))  # ‚Üê Detects credit card

    # NER-based detection (requires spaCy)
    if self.config.use_ner:
        entities.extend(self._detect_with_ner(text))    # ‚Üê Detects again!

    # Sort by position
    entities.sort(key=lambda e: e.start_position)

    return entities  # ‚Üê Duplicates in list
```

### Solution
Implement **deduplication logic** to remove overlapping entities:

```python
def detect_pii(self, text: str) -> List[RedactedEntity]:
    """Detect all PII/PCI/PHI entities in text"""
    entities = []

    if not self.config.enabled:
        return entities

    # Regex-based detection
    if self.config.use_regex:
        entities.extend(self._detect_with_regex(text))

    # NER-based detection (requires spaCy)
    if self.config.use_ner:
        entities.extend(self._detect_with_ner(text))

    # Deduplicate overlapping entities
    entities = self._deduplicate_entities(entities)

    # Sort by position
    entities.sort(key=lambda e: e.start_position)

    return entities

def _deduplicate_entities(self, entities: List[RedactedEntity]) -> List[RedactedEntity]:
    """Remove overlapping duplicate entities, keeping highest confidence"""
    if not entities:
        return entities
    
    # Sort by position and confidence (descending)
    sorted_entities = sorted(
        entities, 
        key=lambda e: (e.start_position, -e.confidence)
    )
    
    deduplicated = []
    for entity in sorted_entities:
        # Check if this entity overlaps with any already added
        overlaps = False
        for existing in deduplicated:
            # Check for overlap
            if not (entity.end_position <= existing.start_position or 
                    entity.start_position >= existing.end_position):
                overlaps = True
                break
        
        if not overlaps:
            deduplicated.append(entity)
    
    return deduplicated
```

---

## üî¥ ISSUE #4: PII Not Being Properly Redacted (Redaction Logic)

### Problem
**Expected:** When PII is detected, it should be redacted with entity-specific tokens
```json
{
  "allowed": true,
  "redacted_input": "What is my credit card number [CREDIT_CARD_REDACTED]?",
  "blocked": false,
  "block_reason": null
}
```

**Actual:** PII is detected but not properly redacted or tracked

### Root Cause
**File:** `sentinel/input_guard.py`  
**Lines:** 793-850

The input guard detects PII but the redaction must be properly applied before returning to server.py:

```python
# Current code might not be properly redacting
risk_score = self.calculate_risk_score(entities, injection_result)
state["risk_scores"].append(risk_score.dict())

# MISSING: Proper redaction and state tracking
```

### Solution
Ensure PII redaction is properly applied and state is captured:

**File:** `sentinel/input_guard.py`  
**Location:** Around line 847 in InputGuardAgent.process()

```python
# After detecting PII entities:
if entities and len(entities) > 0:
    # PII detected - redact the input
    redacted_text = req.user_input
    
    # Sort entities by position (descending) to redact from end to start
    sorted_entities = sorted(entities, key=lambda e: e.start_position, reverse=True)
    
    for entity in sorted_entities:
        # Get entity-specific redaction token
        redaction_token = f"[{entity.entity_type.upper()}_REDACTED]"
        
        # Replace the detected PII with token
        redacted_text = (
            redacted_text[:entity.start_position] + 
            redaction_token + 
            redacted_text[entity.end_position:]
        )
    
    # Update state with redacted input
    state["redacted_input"] = redacted_text
    state["pii_detected"] = True
    state["pii_count"] = len(entities)
    state["should_block"] = False  # Don't block - redaction handled it
    state["block_reason"] = None
    
    # Add security threat for logging
    threat = SecurityThreat(
        threat_type="pii_leakage",
        severity=ThreatLevel.MEDIUM,
        description=f"Detected and redacted {len(entities)} PII entity(ies): {', '.join([e.entity_type for e in entities])}",
        detection_method="input_guard",
        confidence=entities[0].confidence,
        evidence={
            "entity_types": [e.entity_type for e in entities],
            "count": len(entities),
        },
        blocked=False,  # Not blocking, just redacting
    )
    state["security_threats"].append(threat.dict())
```

---

## üìù Summary of Required Changes

| Issue | File | Line | Fix |
|-------|------|------|-----|
| **#1: Generic redaction** | server.py | 490 | Use `result_state.get("redacted_input")` instead of `[PII Redacted]` |
| **#2: Zero risk score** | server.py | 474-479 | Use aggregated risk score from `result_state` |
| **#3: Duplicate PII count** | input_guard.py | 212-230 | Add `_deduplicate_entities()` method |
| **#4: Not blocking on PII** | input_guard.py | 847+ | Add blocking logic when entities are detected |

---

## ‚úÖ Implementation Checklist

### Step 1: Fix Redaction Output (server.py:490)
```python
# Change from:
redacted_input = req.user_input if not pii_detected else "[PII Redacted]"

# Change to:
redacted_input = result_state.get("redacted_input", req.user_input)
```

### Step 2: Fix Risk Score (server.py:474-479)
```python
# Change from:
max_risk_score = 0.0
if threats:
    ...

# Change to:
aggregated_risk = result_state.get("aggregated_risk", {})
max_risk_score = aggregated_risk.get("overall_risk_score", 0.0)

if max_risk_score == 0.0 and threats:
    if isinstance(threats[0], dict):
        max_risk_score = max([t.get("risk_score", 0.0) for t in threats], default=0.0)
    else:
        max_risk_score = max([t.risk_score for t in threats], default=0.0)
```

### Step 3: Deduplicate Entities (input_guard.py:212-230)
Add the `_deduplicate_entities()` method to PIIDetector class.

### Step 4: Block on PII Detection (input_guard.py:847+)
Add blocking logic when PII entities are detected.

---

## Expected Response After Fixes

```json
{
  "allowed": true,
  "redacted_input": "What is my credit card number [CREDIT_CARD_REDACTED]?",
  "risk_score": 0.95,
  "risk_level": "high",
  "blocked": false,
  "block_reason": null,
  "pii_detected": true,
  "pii_count": 1,
  "injection_detected": false,
  "escalated": false,
  "processing_time_ms": 87.5,
  "session_id": "session_xxx"
}
```

**Note:** PII is detected and properly redacted, so `allowed: true` and `blocked: false`. The input is safe to process after redaction.

---

## üîß Testing After Fixes

```bash
curl -X POST http://localhost:8000/process \
  -H "Content-Type: application/json" \
  -d '{
    "user_input": "What is my credit card number 4532-1234-5678-9010?",
    "user_id": "pii_test_002"
  }'
```

Expected: `pii_count: 1`, `blocked: true`, properly redacted input

---

**Status:** Ready for implementation  
**Severity:** Critical (affects core security functionality)  
**Implementation Time:** ~1 hour

